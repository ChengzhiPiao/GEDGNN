from utils import tab_printer
from trainer import Trainer
from param_parser import parameter_parser
from visual import matrix_to_fig
import torch
from greedy_algo import hungarian
from kbest_matching_with_lb import KBestMSolver
import dgl

def test_matching(model, data, test_k, greedy=False):
    if greedy:
        # the Hungarian algorithm, use greedy matching matrix
        pre_ged = None
        soft_matrix = hungarian(data) + 1.0
    else:
        # use the matching matrix generated by GedGNN
        _, pre_ged, soft_matrix = model(data)
        m = torch.nn.Softmax(dim=1)
        # soft_matrix = (m(soft_matrix) * 1e9 + 1).round()
        # soft_matrix = torch.sigmoid(soft_matrix)
        soft_matrix = m(soft_matrix)

    n1, n2 = soft_matrix.shape
    # print(data["edge_index_1"].shape)
    g1 = dgl.graph((data["edge_index_1"][0], data["edge_index_1"][1]), num_nodes=n1)
    g2 = dgl.graph((data["edge_index_2"][0], data["edge_index_2"][1]), num_nodes=n2)
    g1.ndata['f'] = data["features_1"]
    g2.ndata['f'] = data["features_2"]

    solver = KBestMSolver(soft_matrix, g1, g2)
    solver.get_matching(test_k)
    print(len(solver.subspaces))
    for spid, sp in enumerate(solver.subspaces):
        print(spid, sp.best_matching, round(sp.best_res, 2), sp.ged)


def main():
    """
    Parsing command line parameters, reading data.
    Fitting and scoring a SimGNN model.
    """
    args = parameter_parser()
    tab_printer(args)
    trainer = Trainer(args)

    if args.model_epoch_start > 0:
        trainer.load(args.model_epoch_start)

    trainer.cur_epoch = args.model_epoch_start

    print(len(trainer.graphs))
    # in AIDS testing
    # gid: 30 and 91
    # list id: 561 and 565
    for list_id, g in enumerate(trainer.graphs):
        if g['gid'] in [30, 91]:
            print(list_id, g)

    trainer.model.eval()
    data = trainer.pack_graph_pair((0, 561, 565))
    target, gt_ged = data["target"].item(), data["ged"]
    print(target, gt_ged)
    model_out = trainer.model(data)
    prediction, pre_ged, matching = model_out[0], model_out[1], model_out[2]
    round_pre_ged = round(pre_ged)
    print(prediction, pre_ged)

    #print(matching)
    #matrix_to_fig(matching.tolist(), 'matching')

    m = torch.nn.Softmax(dim=1)
    soft_matrix = m(matching)
    print((soft_matrix * 1000).int())

    """
    soft_matrix = hungarian(data)
    tmp = soft_matrix.tolist()
    n1, n2 = len(tmp), len(tmp[0])
    hb = 2 * (n1 + n2)
    for i in range(n1):
        for j in range(n2):
            tmp[i][j] = int(hb - tmp[i][j])
    for row in tmp:
        print(*row, sep='\t')
    matrix_to_fig(tmp, 'greedy')
    """

    #print((soft_matrix * 1000).round())
    #matrix_to_fig(soft_matrix.tolist(), 'soft1_Blues')
    test_matching(trainer.model, data, 20)

    #soft_matrix = (m(matching) * 1e9 + 1).round()
    #print(soft_matrix)
    #matrix_to_fig(soft_matrix.tolist(), 'soft2')




    # trainer.score('test', test_k=1)

    # trainer.batch_score('test', test_k=100)
    # trainer.batch_score('test_large', test_k=10)
    # trainer.batch_score('test_small', test_k=10)

    # trainer.score('test_large', test_k=0) # noah
    """
    test_matching = True
    trainer.cur_epoch = args.model_epoch_start
    #trainer.score('val', test_matching=test_matching)
    trainer.score('test', test_matching=test_matching)
    #if not args.demo:
     #   trainer.score('test2')
    """

if __name__ == "__main__":
    main()
